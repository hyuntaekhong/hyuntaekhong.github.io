---
title: "[Java 24] 자바 - 제네릭"
date: 2020-05-04
categories:
  - blog
tags:
  - Java
comments: true
excerpt: 자바 API 클래스 중 자주 쓰이는 API를 알아보도록 하겠습니다.
last_modified_at: 2020-05-04
toc: true
---

## 학습목표

1. 

## 제네릭 타입 (class<T>, interface<T>)

제네릭 타입은 타입을 파라미터로 가지는 클래스와 인터페이스를 말합니다. 

```java
public class 클래스명<T> {...}
public interface 인터페이스명<T> {...}
```

**예제 1**

[Box] 클래스 

```java
public class Box {
	private Object object;	//필드에 모든 종류의 객체를 저장하기 위해 Object타입 선언
	public void set(Object object) { this.obbject = object; }
	public Object get() { return object; }
}
```

[Apple] 클래스

```java
public class Apple {
}
```

[BoxExample] 비제네릭 타입 이용

```java
public class BoxExample {
	public static void main(String[] args]) {
		Box box = new Box();
		box.set("홍길동");	// String -> Object (자동 타입 변환)
		String name = (String) box.get(); // Object -> String (강제 타입 변환)

		box.set(new Apple());	// Apple -> Object (자동 타입 변환)
		Apple apple = (Apple) box.get(); // Object -> Apple (강제 타입 변환) 
	}
}
```

이처럼 Object 타입을 사용하면 모든 자바 객체를 저장할 수 있다는 장점이 있지만, 저장할 때마다 타입 변환이 발생하고, 읽어올 때도 타입변환이 생깁니다. 이처럼 타입변환이 잦아지게 되면 프로그램 성능에 좋지 않은 영향을 끼칩니다. 그렇다면 이 매번 발생하면 타입 변환을 해결해준다면 문제는 해결될 것입니다. 이 해결책이 바로 제네릭입니다. 

----------------------------------------------

**예제 2**

[Box] 수정된 Box 클래스 

```java
public class Box<T> {
	// Object 타입을 모두 T로 대체
	private T t;	
	public void set(T t) { this.t = t; }
	public T get() { return t; }
}
```

위의 수정된 Box클래스는 타입 파라미터 T를 사용해서 Object 객체를 모두 T로 대체했습니다. T는 Box 클래스로 객체를 생성할 때 구체적인 타입으로 변경됩니다. 

다음과 같이 Box 객체를 생성했다고 가정해봅시다.

```java
Box<String> box = new Box<String>();
```

타입 파라미터 T는 String으로 변경되어 Box 클래스는 내부적으로 다음과 같이 자동적으로 재구성됩니다. 

```java
public class Box<String> {
	// T는 String 타입으로 변경되어 다음과 같이 재구성
	private String t;	
	public void set(String t) { this.t = t; }
	public String get() { return t; }
}
```

필드 타입이 String으로 변경되었고, set() 메소드 역시 String 타입만 매개값으로 받게 되었습니다. 
그래서 다음 코드를 보면 저장할 때와 읽어올 때 타입 변환 없이 사용할 수 있습니다.


```java
Box<String> box = new Box<String>();
box.set("hello");
String str = box.get();
```

-----------------------------------------------

**예제 3**

이번에는 다음과 같이 Box 객체를 생성했다고 가정해봅시다.

```java
Box<Integer> box = new Box<Integer>();
```

타입 파라미터 T는 Integer으로 변경되어 Box 클래스는 내부적으로 다음과 같이 자동적으로 재구성됩니다.


```java
public class Box<Integer> {
	// T는 Integer 타입으로 변경되어 다음과 같이 재구성
	private Integer t;	
	public void set(Integer t) { this.t = t; }
	public Integer get() { return t; }
}
```

그러면 실제적인 코드에서 다음과 같이 타입변환이 최소화해 사용할 수 있습니다.


```java
Box<Integer> box = new Box<Integer>();
box.set(6);
int value = box.get();
```


-----------------------------------------------

**예제 4**

예제 1의 예제를 제네릭을 사용하면 다음과 같이 작성할 수 있습니다.

```java
public class Box<T> {
	private T t;	
	public void set(T t) { this.t = t; }
	public T get() { return t; }
}
```



```java
public class BoxExample {
	public static void main(String[] args]) {
		Box<String> box1 = new Box<String>();
		box.set("hello");	
		String str = box.get(); 

		box<Integer> box2 = new Box<Integer>();
		box2.set(6);
		int value = box2.get(); 
	}
}
```

<br/>


## 멀티 타입 파라미터

제네릭은 두 개 이상의 멀티 타입 파라미터를 사용할 수 있는데, 이 경우 각 타입 파라미터를 콤마로 구분합니다. 

```java
public class Product<T, M> {
	private T kind;
	private M model;

	public T getKind() { return this.kind; }
	public M getModel() { return this.model; }
	public void setKind(T kind) { this.kind = kind;	}
	public void setModel(M model) {	this.model = model;	}
}
```

```java
public class ProductExample {
	public static void main(String[] args) {
		Product<Tv, String> product1 = new Product<Tv, String>();
		product1.setKind(new Tv());
		product1.setModel("스마트 TV");
		Tv tv = product1.getKind();
		String tvModel = product1.getModel();

		Product<Car, String> product2 = new Product<Car, String>();
		product2.setKind(new Car());
		product2.setModel("디젤");
		Car car = product2.getKind();
		String carModel = product2.getModel();
	}
}
```